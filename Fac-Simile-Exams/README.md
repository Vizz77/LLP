This folder will contain exercises that are generated with AI for practice.

Esercizi proposti (solo testo, senza soluzioni):

1) Lista: scrivere una funzione `pari_lib` che restituisce gli elementi in posizione pari (0,2,4,...) usando solo funzioni di libreria; e una versione `pari_ric` ricorsiva.

2) Lista ordinabile: definire `inversioni_lib` che conta quante volte un elemento è maggiore del successivo usando solo funzioni di 
libreria; e `inversioni_ric` ricorsiva.

3) Lista di interi: definire `ultimo_pari_lib` (non ricorsiva) che restituisce l’ultimo numero pari oppure `Nothing` se non esiste; e `ultimo_pari_ric` ricorsiva.

4) Due liste: definire `diverso_lib` che verifica se esiste un elemento della prima lista diverso da tutti gli elementi della seconda, usando funzioni di ordine superiore; e `diverso_ric` ricorsiva.

5) Lista: definire `posizioni_dispari` che restituisce gli elementi in posizione dispari, prima con libreria e poi ricorsiva.

6) Lista ordinabile: definire `cambi_di_segno` che conta quante volte due elementi consecutivi cambiano segno (da negativo a positivo o viceversa), in versione libreria e ricorsiva.

7) Lista: definire `prefissi_validi` che, data una lista di interi, restituisce tutti i prefissi con somma non negativa; versione con libreria e ricorsiva.

8) Lista: definire `drop_ogni_n` che elimina ogni n-esimo elemento (n > 0), in versione libreria e ricorsiva.

9) Albero n-ario: definire un tipo `Tree` con costruttori `Empty` e `Node`, poi scrivere `elements` che restituisce tutti gli elementi in visita pre-order.

10) Albero n-ario: definire `normalize` che rimuove i sottoalberi vuoti da un albero, mantenendo la struttura degli altri nodi.

11) Albero n-ario: definire `altezza` che calcola l’altezza dell’albero (Empty ha altezza 0), e `num_nodi` che conta i nodi.

12) Albero n-ario: definire `mapTree` che applica una funzione a tutti i valori dei nodi.

13) Lista: definire `run_length` che comprime una lista in coppie (valore, occorrenze consecutive); poi `expand` che ricostruisce la lista.

14) Lista: definire `is_strictly_increasing` che verifica se la lista è strettamente crescente, versione libreria e ricorsiva.

15) Lista: definire `split_on` che divide una lista in sottoliste usando un predicato di separazione (gli elementi che soddisfano il predicato non devono comparire nelle sottoliste).
